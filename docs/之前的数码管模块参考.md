// ==================== 七段数码管显示控制器 ====================
module Display_Controller(
    input  wire        clk,
    input  wire        rst_n,
    input  wire [31:0] data,
    output reg  [7:0]  seg_sel,
    output reg  [7:0]  seg_data_left,
    output reg  [7:0]  seg_data_right
);

// 显示刷新计数器
reg [2:0] digit_sel;

// 七段码表：bit0=A, bit1=B, ..., bit6=G, bit7=DP，1 为点亮
function [7:0] hex_to_seg;
    input [3:0] hex;
    begin
        case(hex)
            4'h0: hex_to_seg = 8'b00111111; // 0
            4'h1: hex_to_seg = 8'b00000110; // 1
            4'h2: hex_to_seg = 8'b01011011; // 2
            4'h3: hex_to_seg = 8'b01001111; // 3
            4'h4: hex_to_seg = 8'b01100110; // 4
            4'h5: hex_to_seg = 8'b01101101; // 5
            4'h6: hex_to_seg = 8'b01111101; // 6
            4'h7: hex_to_seg = 8'b00000111; // 7
            4'h8: hex_to_seg = 8'b01111111; // 8
            4'h9: hex_to_seg = 8'b01101111; // 9
            4'hA: hex_to_seg = 8'b01110111; // A
            4'hB: hex_to_seg = 8'b01111100; // b
            4'hC: hex_to_seg = 8'b00111001; // C
            4'hD: hex_to_seg = 8'b01011110; // d
            4'hE: hex_to_seg = 8'b01111001; // E
            4'hF: hex_to_seg = 8'b01110001; // F
        endcase
    end
endfunction

// 数码管扫描（位选高电平有效）
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        digit_sel      <= 3'd0;
        seg_sel        <= 8'b00000001;
        seg_data_left  <= 8'b00000000;
        seg_data_right <= 8'b00000000;
    end
    else begin
        digit_sel      <= digit_sel + 1;
        seg_sel        <= 8'b00000000;
        seg_data_left  <= 8'b00000000;
        seg_data_right <= 8'b00000000;
        
        // 从左到右：最高位在左，最低位在右
        case(digit_sel)
            3'd0: begin
                seg_sel[0]     <= 1'b1;           // 左1 显示最高位
                seg_data_left  <= hex_to_seg(data[31:28]);
            end
            3'd1: begin
                seg_sel[1]     <= 1'b1;           // 左2
                seg_data_left  <= hex_to_seg(data[27:24]);
            end
            3'd2: begin
                seg_sel[2]     <= 1'b1;           // 左3
                seg_data_left  <= hex_to_seg(data[23:20]);
            end
            3'd3: begin
                seg_sel[3]     <= 1'b1;           // 左4
                seg_data_left  <= hex_to_seg(data[19:16]);
            end
            3'd4: begin
                seg_sel[4]     <= 1'b1;           // 右1
                seg_data_right <= hex_to_seg(data[15:12]);
            end
            3'd5: begin
                seg_sel[5]     <= 1'b1;           // 右2
                seg_data_right <= hex_to_seg(data[11:8]);
            end
            3'd6: begin
                seg_sel[6]     <= 1'b1;           // 右3
                seg_data_right <= hex_to_seg(data[7:4]);
            end
            3'd7: begin
                seg_sel[7]     <= 1'b1;           // 右4 显示最低位
                seg_data_right <= hex_to_seg(data[3:0]);
            end
        endcase
    end
end

endmodule
