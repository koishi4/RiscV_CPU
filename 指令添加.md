# 指令添加.md

> 面向本项目（RV32 五级流水 + mul/div 单元 + MMIO 外设 + 多hart/调度）的**自定义指令扩展添加 Agent**规范文档
> 目标：在**不破坏现有功能**的前提下，稳定地新增（例如卷积/矩阵加速）≥20 条专用指令，并提供可回归的验证与文档化流程。

---

## 0. 适用范围与设计原则

### 0.1 适用范围

* **短延迟（1~2 cycle）**：适合放在 EX 级组合/小流水的 SIMD/点积/饱和/重排等指令（强烈推荐先做这一类）。
* **长延迟（多 cycle/offload）**：适合做“整块卷积/整块矩阵”加速器启动/轮询/等待等控制类指令（推荐作为第二阶段）。

### 0.2 总原则（必须满足）

1. **兼容性**：不改变现有 RV32I/M（以及现有 SYSTEM/CSR/MMIO）语义。
2. **可回归**：每条新增指令必须有**最小测试用例**（汇编 + C 参考模型）。
3. **可综合**：默认实现不依赖不可综合 construct；乘法尽量映射 DSP。
4. **不引入死锁**：与现有 mul/div pending 写回、barrel scheduler/hazard 机制不冲突。
5. **可扩展编码**：同类指令使用统一编码字段分组，便于后续再扩展 20→40→80 条。

---

## 1) 指令扩展总体方案（Custom-0 细粒度 + Custom-1 粗粒度）

### 1.1 Opcode 空间选择

* **custom-0**：放短延迟 SIMD/点积/pack 等（主力，最稳）
* **custom-1**：放长延迟 offload/DMA/卷积矩阵控制（第二阶段）

> 建议：先用 custom-0 做 ≥20 条“像普通 ALU 一样写回”的指令，立刻提升 conv/gemm inner-loop；
> 后续再用 custom-1 引入“整块 offload”类指令，获得更大吞吐提升。

### 1.2 格式选择

* **R-type**：rs1/rs2 → rd（SIMD 算术/点积/pack）
* **I-type**：rs1 + imm → rd（移位/量化/clip）
* **(可选) R4-type / 自定义格式**：用于 offload 指令携带更多字段（不建议第一阶段就上）

---

## 2) 细粒度：面向 Conv/GEMM/int8 推理的 ≥20 条指令集合（示例：28 条）

> 你可以删减到 20+，但建议保留 DOT/MAC、饱和算术、shift/round、pack/unpack 这四类。

### A. 点积/累加（6）——卷积/矩阵乘“发动机”

1. KDOT4.SS   4×(int8×int8) 累加 → int32
2. KDOT4.SU
3. KDOT4.UU
4. KMAC4.SS   rd ← rd + dot4
5. KMAC4.SU
6. KMAC4.UU

### B. 8-bit SIMD 基本算术（10）——融合算子常用

7. KADD8        按 byte 加（wrap）
8. KSUB8
9. KADDSAT8     按 byte 饱和加（signed）
10. KSUBSAT8
11. KMAX8        signed max
12. KMIN8
13. KABS8        abs（rs2 忽略）
14. KAVG8        (a+b+1)>>1
15. KADD16       按 halfword 加（wrap）
16. KADDSAT16    按 halfword 饱和加（signed）

### C. 移位/量化（6）——量化推理必备

17. KSHL8I        byte 逻辑左移 imm
18. KSHR8I        byte 算术右移 imm
19. KSRU8I        byte 逻辑右移 imm
20. KRSHR8I       byte rounding arshift
21. KCLAMP8I      byte clamp 到 [-imm,+imm]（建议 imm=5~6bit）
22. KRELU8        byte relu：max(x,0)（rs2 忽略）

### D. pack/unpack/重排（6）——提升访存/对齐效率

23. KPACKB        打包低 2B+低 2B → 4B
24. KPACKH        打包低 H+低 H → 2H
25. KUNPK8L.S     低两 byte → 两个 sign-ext halfword
26. KUNPK8H.S     高两 byte → 两个 sign-ext halfword
27. KREV8         字节反转（abcd→dcba）
28. KSWAP16       halfword 交换（h1h0→h0h1）

---

## 3) 粗粒度：卷积/矩阵“整块 offload”指令（Custom-1，建议 6~12 条）

> 这类指令让 CPU 不再执行 inner-loop，而是把工作交给片上加速器（可配 DMA），CPU 可选择等待或并行做别的事（多hart/调度时收益更明显）。

### 3.1 总体接口：描述符 + token/job_id

* 软件在内存中构建一个 **descriptor（描述符）结构体**，包含：

  * 输入/权重/输出基地址
  * shape（M,N,K 或 N,H,W,C,KH,KW 等）
  * stride/padding/dilation
  * quant 参数（zero-point, scale, shift, clamp）
  * 激活融合（relu/clip）
* 指令只传：descriptor 地址 + flags → 返回 job_id

### 3.2 建议指令集（8 条）

1. **KACCEL.START**  `rd=job_id, rs1=desc_ptr, rs2=flags`
2. **KACCEL.POLL**   `rd=status, rs1=job_id`（0=done, 1=busy, 2=err...）
3. **KACCEL.WAIT**   `rd=ret, rs1=job_id`（阻塞等待完成，可被中断唤醒）
4. **KACCEL.CANCEL** `rd=ret, rs1=job_id`
5. **KACCEL.FENCE**  `rd=0/ret`（保证加速器写回内存可见，等价于内存栅栏/同步点）
6. **KACCEL.GETERR** `rd=errcode, rs1=job_id`
7. **KACCEL.SETCFG** `rd=ret, rs1=cfg_id, rs2=value`（小量全局配置/调试）
8. **KACCEL.GETCFG** `rd=value, rs1=cfg_id`

> 其中 1~5 就能跑起来“整块 conv/gemm”。其余用于工程化与调试。

### 3.3 Offload 指令的微结构落地要点（非常关键）

* 需要一个 `accel_pending` 写回源（类似你现在 mul/div 的 pending 写回）
* **wb_stage 仲裁必须扩展**：至少做到
  `accel_pending > muldiv_pending > exwb`（简单版）
* 如果支持多 job 并行：需要 job queue + job_id 分配器
* 如果加速器直接读写内存：必须处理与 CPU load/store 的一致性（建议：KACCEL.FENCE 或 wait 内含 fence）

---

## 4) 编码规范（让译码简单、可扩展）

### 4.1 细粒度 custom-0：R-type / I-type 分组建议

* `funct3`：大类（点积/饱和/比较/pack/permute…）
* `funct7`：具体指令编号（0~127 足够）

推荐分组：

* funct3=000：DOT/MAC
* funct3=001：ADD/SUB（含饱和）
* funct3=010：MIN/MAX/ABS/AVG/16bit add
* funct3=100：PACK/UNPACK
* funct3=101：REV/SWAP 等 permute
* funct3=110：RELU/激活类
* funct3=011（I-type）：SHIFT/CLAMP/ROUND（imm[11:5] 再区分子操作）

### 4.2 粗粒度 custom-1：建议固定 funct3 表示“控制类”

* funct3=000：START
* funct3=001：POLL
* funct3=010：WAIT
* funct3=011：CANCEL
* funct3=100：FENCE
* funct3=101：GETERR
* funct3=110：SETCFG
* funct3=111：GETCFG

---

## 5) RTL 集成点（本项目流水线最稳的落地路径）

> 核心：custom-0 全部走 EX 级结果 → 普通写回。
> custom-1（offload）走 accel_unit + pending 写回 + wb 仲裁。

### 5.1 custom-0（细粒度）修改清单（最小集合）

1. `defines.vh`：custom opcode 常量、funct3/funct7 编号
2. `id_stage.v`：识别 custom0 + illegal
3. `ex_stage.v`：`custom0_execute` 组合逻辑产出 `custom_result`
4. `cpu_top.v`：让 custom0 参与 `ex_wb_en`
5. `trap_ctrl.v`：未知编码 → illegal trap
6. `hazard_fwd.v`：通常无需改；若按类型判定，补充 custom0=ALU 类

### 5.2 custom-1（粗粒度）新增模块与仲裁点

* 新增：`accel_unit.sv`（或在现有 `dma_engine`/`mmio_fabric` 基础上扩展）
* 新增：`accel_pending_valid/rd/data`（类似 muldiv_pending）
* 修改：`wb_stage.v` 扩展仲裁（至少三方）
* 修改：`trap/irq` 交互（WAIT 可被中断打断，或支持轮询）

---

## 6) 软件侧接入与验证（不改工具链也能用）

* 提供 `include/custom_instr.h`：每条指令的 `.insn` intrinsic + 纯 C reference
* 每条指令至少：随机 + 边界两类用例，并覆盖 RAW/WAW、与 load/store/muldiv 交错
* custom-1 额外覆盖：START/POLL/WAIT/CANCEL/FENCE 状态机与一致性

---

## 7) 推荐的“先做哪 20 条”（最快出效果）

1. DOT4.SS/SU/UU + MAC4.SS/SU/UU（6）
2. KADDSAT8/KSUBSAT8/KMAX8/KMIN8/KABS8/KAVG8（6）
3. KSHR8I/KSRU8I/KRSHR8I/KSHL8I（4）
4. KPACKB/KUNPK8L.S/KUNPK8H.S/KREV8（4）
   合计 20 条。

---

## 8) 如果你明确要“卷积/矩阵 offload 指令”也计入 ≥20 条

* 在上面 20 条基础上，加上 custom-1 的 8 条（START/POLL/WAIT/CANCEL/FENCE/GETERR/SETCFG/GETCFG）
* 整体变为 **28（custom-0）+8（custom-1）=36 条**，覆盖“算子级 + 整块级”两种加速方式。

---
