## 1) 先冻结你们的 RISC‑V “最小可行规格”（否则两个人会互相卡）

### 1.1 ISA 建议：RV32I + RV32M + SYSTEM(最小 CSR + mret)

**必须保证基础能跑**：

* RV32I：算术/逻辑、立即数、分支、跳转、load/store（至少 `lw/sw`）
* RV32M：`mul/mulh/mulhu/mulhsu/div/divu/rem/remu`（你们只要挑一部分也行，但申优建议尽量全）
* SYSTEM（最小集合）：

  * CSR 读写：至少支持 `csrrw/csrrs`（就够写 `mtvec/mstatus/mie`、读 `mhartid`）
  * `mret`（返回中断）
  * `ecall/ebreak` 可不做（或当 illegal 处理）

> 重点：你们做的是 **2 个硬件线程 = 2 个 hart**。
> 软件里用 `mhartid` 判断 “我是 hart0 还是 hart1”。

### 1.2 Machine‑mode CSR 最小集合（为 DMA 中断服务）

建议实现这些就够你们写出“标准 RISC‑V 风格中断”：

* `mhartid`（只读，返回 0/1）
* `mtvec`（中断向量基址，先只做 direct 模式）
* `mepc`（保存返回 PC）
* `mcause`（保存中断原因：建议用 **Machine external interrupt**）
* `mstatus`（至少实现 MIE 位：bit3）
* `mie` / `mip`（只做 MEIE/MEIP：bit11）

---

## 2) 多线程（2‑hart barrel）在实现上怎么写最稳

你们前面说“重写”，我建议直接用 **barrel pipeline 的“按 hart 分 bank 的流水寄存器”**，它对“只阻塞某个线程”非常友好。

### 2.1 推荐的实现方式：**每级流水寄存器按 hart 分 bank**

每个 stage 的 pipeline reg 都是数组 `[hart]`：

* `IFID[2]`, `IDEX[2]`, `EXMEM[2]`, `MEMWB[2]`
* 每个 bank 里包含：`valid, pc, inst, rs1, rs2, rd, imm, ctrl...`

每个周期选择一个 `cur_hart`：

* round‑robin：0→1→0→1…
* 如果 `blocked[cur_hart]==1`，就跳到另一个 hart（或本周期不推进这个 hart 的流水）

**关键收益**：

* 你可以“只冻结 hart0 的流水寄存器”，hart1 完全照常推进
* MUL/DIV 多周期、DMA 等待、中断处理都更容易做“线程隔离”

### 2.2 约定：每个 hart 独立状态

* `PC[2]`
* `RegFile[2][32]`（x0 恒为 0）
* `blocked[2]`（比如 muldiv busy）
* CSR 可做成 **每 hart 一套**（更贴近真实多 hart），也可做全局 + per‑hart mepc/mcause（最低建议：mepc/mcause/mstatus/mie/mip per‑hart，mhartid只读）

---

## 3) DMA 的内存映射（直接给你们一个能用的 map）

建议 MMIO 基址（你们可改，但要固定）：

* `DMA_BASE = 0x4000_0000`

寄存器布局（32-bit）：

| 地址              | 名称         | 说明                             |
| --------------- | ---------- | ------------------------------ |
| `DMA_BASE+0x00` | `DMA_SRC`  | 源地址（byte address）              |
| `DMA_BASE+0x04` | `DMA_DST`  | 目的地址                           |
| `DMA_BASE+0x08` | `DMA_LEN`  | 长度（byte 或 word，建议 byte）        |
| `DMA_BASE+0x0C` | `DMA_CTRL` | bit0 START, bit1 IRQ_EN        |
| `DMA_BASE+0x10` | `DMA_STAT` | bit0 BUSY, bit1 DONE, bit2 ERR |
| `DMA_BASE+0x14` | `DMA_CLR`  | 写 1 清 DONE/ERR                 |

### DMA 搬运 FSM（建议最稳的版本）

* 支持 **memory‑to‑memory copy** 就够演示
* 每次搬运 32-bit word：
  `read(src)` → `write(dst)` → `src+=4, dst+=4, len-=4`

### 内存接口建议（你们非常适合用双口 BRAM）

* Port A：CPU
* Port B：DMA
  这样 DMA 不抢 CPU 口 → 演示时“真正并行”效果非常明显。

---

## 4) MUL/DIV 单元接口（写死接口后两人就能并行）

建议 MUL/DIV 独立为 `muldiv_unit.sv`，握手信号如下：

**输入：**

* `start`
* `op[2:0]`（例如 0=mul,1=mulh,2=div,3=rem...）
* `a[31:0], b[31:0]`
* `hart_id`（1 bit）
* `rd[4:0]`（目的寄存器号）

**输出：**

* `busy`
* `done`
* `result[31:0]`
* `done_hart_id`
* `done_rd`

### CPU 集成策略（最容易、最能体现多线程价值）

* hartX 发起 MUL/DIV → 立刻 `blocked[X]=1`
* 调度器跳过 blocked 的 hart
* `done` 到来 → 写回 `RegFile[X][rd]` → `blocked[X]=0`

> 你们答辩时能展示：
> hart0 做大量 mul/div，hart1 仍然持续跑（比如点灯/输出计数）
> 这就是“硬件多线程 + 多周期算术单元”的协同亮点。

---

## 5) 两个人怎么分工（按 RISC‑V 实际工作量细化到“可验收交付物”）

### 成员 A：**CPU 核心 + 多线程 + CSR/中断（主线）**

A 的任务包（按交付物）：

1. **RV32I 流水线/译码/执行主链路**

* 交付：单 hart 能跑 RV32I（至少 `lw/sw/branch/jal/jalr/addi` 等）

2. **2-hart barrel 调度 + banked pipeline regs**

* 交付：两个 hart 同时跑、寄存器互不污染（演示用例见后面 Demo1）

3. **CSR 文件（最小 Machine‑mode） + trap 入口/`mret`**

* 交付：能 `csrw mtvec`、能开中断、能进 ISR、能 `mret` 返回

4. **muldiv 的 CPU 侧集成（blocked/写回仲裁）**

* 交付：M 扩展指令在 CPU 指令流里能用

> A 的核心 KPI：把“2-hart + trap”的主线跑通。

---

### 成员 B：**mul/div 算法实现 + DMA/内存子系统（亮点硬件）**

B 的任务包：

1. **muldiv_unit：Booth 乘法 + non‑restoring 除法（多周期）**

* 交付：独立 testbench 随机对拍通过（1000+ vectors）
* 输出 done 携带 `hart_id/rd`（便于 CPU 写回）

2. **DMA engine：寄存器接口 + 搬运 FSM**

* 交付：仿真中能把一段内存从 src 拷贝到 dst 正确

3. **mem_subsystem：双口 BRAM /（可选）仲裁版本**

* 交付：CPU 与 DMA 可并发访问不互相踩坏数据

4. **DMA done → irq 信号/挂到 mip**

* 交付：DMA 完成会拉起 “machine external interrupt pending”

> B 的核心 KPI：muldiv 和 DMA 都能独立自测并给出稳定接口。

---

### 两人共同（一定要一起做，不然集成会炸）

* **接口冻结 + memory map 文档（SPEC.md）**
* **三套 demo 汇编 + 回归测试脚本**
* **板上验证与展示录屏**

---

## 6) 里程碑（用“验收标准”驱动，最适合两人并行）

### Milestone 1：单 hart RV32I 跑通（A 主，B 写 test）

* 验收：仿真跑完，内存/寄存器结果 match

### Milestone 2：2-hart barrel 跑通（A 主，B 压测）

* 验收：两 hart 同时算不同任务，写不同内存，结果都对

### Milestone 3：muldiv 单元接入 + 多线程隐藏延迟（B 主，A 集成）

* 验收：hart0 mul/div 压测同时 hart1 仍持续输出计数/点灯

### Milestone 4：DMA + 中断（B 主 DMA，A 主 trap/mret）

* 验收：CPU 启动 DMA 后继续算，DMA done 触发 ISR，ISR 清中断并返回

---

## 7) 直接给你们三套 RISC‑V Demo 的“汇编骨架”（可复制改）

> 你们只需要保证：`mhartid/mtvec/mstatus/mie/mip/mepc/mcause/mret` 能工作，以及 MMIO 地址按你们实现一致。

### 7.1 Reset 入口：同一份程序，两 hart 各走各的代码

```asm
.section .text
.globl _start
_start:
    csrr  a0, mhartid        # a0 = 0/1
    beqz  a0, hart0_main
    j     hart1_main
```

---

### Demo1：多线程正确性（各算各的，写内存结果）

```asm
# 约定结果地址
.equ RES0, 0x00001000
.equ RES1, 0x00001004

hart0_main:
    # sum = 1..N
    li   t0, 1000
    li   t1, 0
1:  add  t1, t1, t0
    addi t0, t0, -1
    bnez t0, 1b
    li   t2, RES0
    sw   t1, 0(t2)
    j    hart0_main   # 或 halt

hart1_main:
    # fib(n)
    li   t0, 30
    li   t1, 0
    li   t2, 1
2:  add  t3, t1, t2
    mv   t1, t2
    mv   t2, t3
    addi t0, t0, -1
    bnez t0, 2b
    li   t4, RES1
    sw   t2, 0(t4)
    j    hart1_main
```

验收：仿真结束检查 `RES0/RES1`。

---

### Demo2：mul/div 延迟隐藏（hart0 做乘除，hart1 继续跑）

```asm
.equ IO_CNT, 0x40010000   # 你们可映射到 LED/UART/内存计数

hart0_main:
    li t0, 2000
    li t1, 1234567
    li t2, 7654321
3:  mul t3, t1, t2        # 多周期单元
    div t4, t2, t1
    add t5, t3, t4
    addi t0, t0, -1
    bnez t0, 3b
    j hart0_main

hart1_main:
    li t0, IO_CNT
    li t1, 0
4:  addi t1, t1, 1
    sw   t1, 0(t0)        # 连续输出/点灯
    j    4b
```

展示点：hart0 卡在 mul/div 时，hart1 仍持续更新 IO。

---

### Demo3：DMA + 中断（hart0 配 DMA，DMA done 触发 ISR）

先初始化 `mtvec` 并开中断（建议只 hart0 做）：

```asm
.equ DMA_BASE, 0x40000000
.equ DMA_SRC,  (DMA_BASE+0x00)
.equ DMA_DST,  (DMA_BASE+0x04)
.equ DMA_LEN,  (DMA_BASE+0x08)
.equ DMA_CTRL, (DMA_BASE+0x0C)
.equ DMA_STAT, (DMA_BASE+0x10)
.equ DMA_CLR,  (DMA_BASE+0x14)

.equ FLAG, 0x00002000

hart0_main:
    # mtvec = trap_entry
    la   t0, trap_entry
    csrw mtvec, t0

    # 开 machine external interrupt: mie.MEIE=1, mstatus.MIE=1
    li   t0, (1<<11)       # MEIE
    csrs mie, t0
    li   t0, (1<<3)        # MIE
    csrs mstatus, t0

    # 清 flag
    li   t0, FLAG
    sw   zero, 0(t0)

    # 配 DMA：src/dst/len
    li   t0, DMA_SRC
    li   t1, 0x00003000
    sw   t1, 0(t0)

    li   t0, DMA_DST
    li   t1, 0x00004000
    sw   t1, 0(t0)

    li   t0, DMA_LEN
    li   t1, 256           # 256 bytes
    sw   t1, 0(t0)

    # start + irq_en
    li   t0, DMA_CTRL
    li   t1, 0x3           # bit0 START=1, bit1 IRQ_EN=1
    sw   t1, 0(t0)

    # DMA 期间做别的事（例如算 checksum）
    li   t2, 100000
5:  addi t2, t2, -1
    bnez t2, 5b

    # 等待中断写 FLAG
6:  li   t0, FLAG
    lw   t1, 0(t0)
    beqz t1, 6b
    j    hart0_main
```

Trap handler（你们 CPU 触发中断时跳到 mtvec）：

```asm
.align 4
trap_entry:
    # 可选：读 mcause 判断是否 external interrupt
    # csrr t0, mcause

    # 清 DMA done
    li   t0, DMA_CLR
    li   t1, 1
    sw   t1, 0(t0)

    # 设置 flag
    li   t0, FLAG
    li   t1, 1
    sw   t1, 0(t0)

    mret
```

> 你们只要保证：进入中断时 `mepc` 保存正确、`mret` 恢复 PC、DMA done 能拉起中断线。

---

## 8) “接口/目录结构”给你们一个直接可用的模板

建议仓库结构（两人协作不会乱）：

```
rtl/
  core/
    cpu_top.v
    barrel_sched.v
    if_stage.v
    id_stage.v
    ex_stage.v
    mem_stage.v
    wb_stage.v
    regfile_bank.v
    csr_file.v
    trap_ctrl.v
    hazard_fwd.v
  accel/
    muldiv_unit.sv
  periph/
    dma_engine.sv
    mmio_decode.v
    irq_router.v
  mem/
    dualport_bram.sv
tb/
  tb_top.sv
  mem_model.v
  tests/
    rv32i_basic.S
    demo_thread.S
    demo_muldiv.S
    demo_dma_irq.S
docs/
  SPEC.md
  memory_map.md
  pipeline_diagram.drawio
```

分支建议：

* `feat_barrel`（A）
* `feat_muldiv`（B）
* `feat_dma`（B）
* `feat_trap`（A）

---

## 9) 最后给你们一句“分工落地原则”（能极大降低返工）

**A 永远不直接改 B 的模块内部实现；B 永远不直接改 A 的流水线控制。**
大家只通过：

* `interface.vh`（统一信号定义）
* `SPEC.md`（语义约定）
* 单元 testbench（可复现用例）
  来对齐。

这样你们才能做到：并行开发 → 最后集成不崩。
