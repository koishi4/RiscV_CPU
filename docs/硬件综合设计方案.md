## 0. 先定一个“最容易成功又很有特色”的总体方案

三个亮点可以做成一个很漂亮的故事线：

* **两硬件线程（2 contexts）细粒度多线程（barrel）**：每拍轮转取指，或“跳过阻塞线程”。
* **乘/除为多周期高速算术单元**：MUL/DIV 进入执行后不会拖死整个 CPU；被阻塞的线程暂停，另一个线程继续跑 → **多线程天然隐藏乘除延迟**（这个展示非常能打）。
* **DMA + 中断**：CPU 启动 DMA 后继续计算；DMA 完成触发中断，CPU 进入 ISR 处理 → **展示“并行+异步事件”**。

> 这样你们的亮点不是三个“孤立功能”，而是一个**系统级协同优化设计**：
> “多线程隐藏乘除/访存等待，DMA 并行搬运数据，中断实现异步完成通知”。

---

## 1. 架构选型

### 1.1 多线程模型：2-thread barrel + 可跳过阻塞线程

* **线程数**：固定 2 个（最适合两人开发、验证复杂度可控）。
* **每线程状态**（必须独立）：`PC[tid]`、`RegFile[tid]`、`EPC[tid]`/`Status[tid]`（如果做中断）。
* **取指调度**：

  * 默认 round-robin：0→1→0→1……
  * 如果某线程 `blocked[tid]=1`（比如正在等待 MUL/DIV 完成），就**跳过它**，只发射另一个线程。
* **流水线实现方式**：

  * 依旧是你们熟悉的 5 级（IF/ID/EX/MEM/WB）；
  * 关键点：**每级流水寄存器里都带一个 `tid` 字段 + valid 位**。
  * 写回时根据 tid 写回对应的 RegFile。

> 这个选择的最大好处：
> **结构很“像正常流水线”，但加了 tid 标签就能实现多线程**，而且对报告讲解友好。

### 1.2 高速算术单元：多周期 MUL/DIV + 握手接口

建议这样选：

* **乘法**：Radix-4 Booth（部分积更少）+（简化版）CSA 压缩树（可以说是 Wallace/Dadda 风格压缩），最后一拍用 CLA/加法器收敛。
* **除法**：非恢复除法（Non-restoring）或 SRT 的简化版本（本科项目推荐 non-restoring，更稳）。
* **接口**：做成独立模块 `muldiv_unit`，和 CPU 通过握手交互：

  * `start, op, a, b, tid, rd`
  * `busy`
  * `done, result, tid, rd`

CPU 对 MUL/DIV 指令的处理策略（**强烈推荐**）：

* 在 **ID 或 EX** 看到 MUL/DIV 时向 muldiv 发起 `start`；
* 立刻把这个线程标记 `blocked[tid]=1`（阻止该线程继续取指/进入流水）；
* 另一个线程继续运行；
* `done` 到来时，把 `result` 写入 `RegFile[tid][rd]`，清掉 `blocked[tid]`。

> 这会让你们的多线程“有存在感”：
> **单线程 CPU 遇到多周期乘除必然卡住，多线程 CPU 可以继续跑另一线程。**

### 1.3 DMA：存储映射寄存器 + 后台搬运 + 完成中断

DMA 做到能演示即可，不追求极致复杂。

* DMA 寄存器（存储映射）建议至少这些：

  * `SRC` 源地址
  * `DST` 目的地址
  * `LEN` 长度（按 word 还是 byte 自定）
  * `CTRL`（start/irq_en）
  * `STATUS`（busy/done/error）
* DMA 工作方式：

  * CPU 配置寄存器后写 `CTRL.start=1`
  * DMA 进入 busy，执行搬运
  * 搬运完成：`STATUS.done=1`，如果 `irq_en=1` 就拉起中断请求

DMA 和内存连接有两种实现（建议你们按“先稳后秀”的策略）：

* **方案 A（最稳）**：用 **双口 BRAM**

  * CPU 走 Port A
  * DMA 走 Port B
  * CPU 几乎不受 DMA 影响 → “真正并行”
* **方案 B（更有味道）**：单口内存 + 仲裁（cycle stealing）

  * DMA 每 N 个周期抢占 1 次内存访问
  * CPU 对应周期 stall
  * 报告里好讲“带宽争用与优化”，但实现更麻烦

> 推荐路线：先把 A 做出来保证功能；如果时间够，再加 B 作为“性能分析与优化”加分点。

### 1.4 中断（只为 DMA 完成服务就够）

你们不需要做一堆外设中断，**只做 DMA done 一个源**也完全能当亮点。

最简可行语义：

* 只让 **线程 0 响应中断**（线程 1 不响应），这样逻辑最简单；
* 中断到来时：

  * 保存线程0的 `EPC0 <= PC0`（或保存下一条PC）
  * `PC0 <= IRQ_VECTOR`（固定地址或寄存器可配）
  * 设置 `in_irq0=1`
* `eret` 指令恢复 `PC0 <= EPC0`，清 `in_irq0`

---

## 2. 模块拆分

把工程拆成**可并行开发**的模块，接口先冻结，后面集成就不会互相拖。

### 2.1 顶层建议模块

1. `cpu_core.sv` / `cpu_core.v`

   * 流水线、译码、控制、前递/冒险（如果你们做）、tid 标签、写回
2. `thread_ctrl.v`

   * `PC[2]`、`blocked[2]`、调度器（选择本周期 fetch 的 tid）
3. `regfile_bank.v`

   * 2 套寄存器组（bank0/bank1），或一个 regfile + tid 选择
4. `muldiv_unit.sv`

   * 多周期 Booth+压缩树乘法、non-restoring 除法、done 写回信息携带 tid/rd
5. `dma_engine.sv`

   * 寄存器接口 + 搬运 FSM + DMA 访存主接口
6. `mem_subsystem.v`

   * BRAM/外部存储控制器 + CPU/DMA 端口（双口或仲裁）
7. `irq_ctrl.v`（可选，如果你们直接把中断线接 CPU 也行）

   * `dma_done -> irq_pending`、mask、ack

### 2.2 一定要提前写死的接口（双方协作契约）

在 `defines.vh` 里统一定义：

* 数据宽度（比如 32）
* 地址宽度
* 线程数（固定 2）
* 统一的内存请求通道格式（非常重要）：

**CPU 侧内存接口（示例）**

* `cpu_mem_req`
* `cpu_mem_we`
* `cpu_mem_addr`
* `cpu_mem_wdata`
* `cpu_mem_rdata`
* `cpu_mem_ready`（若做 stall）

**DMA 侧内存接口（示例）**

* `dma_mem_req`
* `dma_mem_we`
* `dma_mem_addr`
* `dma_mem_wdata`
* `dma_mem_rdata`
* `dma_mem_ready`

即便你们用双口 BRAM，也建议保留 ready 信号，后面扩展（比如接外部 SRAM）不会重构。

---

## 3. 两个人怎么分：推荐“核心控制” vs “外设/加速器”

下面是我建议的分工方式：**每个人都拥有一个“申优亮点”的主导权**，并且接口清晰、能并行推进。

### 分工总表（建议直接照抄到你们项目计划里）

| 工作包                             | 成员 A（主）     | 成员 B（主）      | 交付物                       |
| ------------------------------- | ----------- | ------------ | ------------------------- |
| CPU 重写骨架（流水线/译码/基本指令）           | ✅           | 协助写测试        | 单线程可跑、仿真通过、板上跑通           |
| 硬件多线程（2 context + tid 标签 + 调度器） | ✅           | 协助 review/压测 | 双线程程序运行正确、分线程寄存器/PC 正确    |
| MUL/DIV 多周期单元                   | 集成/阻塞策略 ✅   | 设计实现 ✅       | muldiv_unit 自测通过，CPU 指令能用 |
| DMA 引擎（寄存器 + FSM + 搬运）          | 协助接入地址映射    | ✅            | DMA 自测：内存到内存拷贝正确          |
| 内存子系统（双口/仲裁）                    | 协助 CPU 接口   | ✅            | CPU+DMA 并发访问不出错           |
| DMA 完成中断 + CPU ISR/ERET         | ✅（CPU侧进出中断） | ✅（irq信号/寄存器） | demo：DMA 完成触发 ISR         |
| 系统集成、板级验证、演示程序                  | ✅（主控）       | ✅（外设/测试）     | 三个演示程序 + 录像/截图            |
| 报告：数据通路图、性能分析、问题排查记录            | ✅（架构章节）     | ✅（DMA/算术章节）  | 完整报告 + 申优申请               |

---

## 4. 具体到“每个人每天做什么”的里程碑计划（可直接执行）

我给你一个按“功能逐层叠加”的顺序（你们可以按实际周期压缩/拉长，但顺序别乱）。

### Phase 0：1–2 天（必须做，不然后面一定乱）

共同完成（两人一起）：

1. 冻结接口：tid、mem接口、muldiv接口、DMA寄存器地址表
2. 画一张“顶层框图”（报告里也能用）
3. 建 git 仓库与分支策略

   * `main`：永远可综合可运行
   * `feat_thread`, `feat_muldiv`, `feat_dma`：各自开发
   * 每次 merge 必须跑仿真回归测试

交付物：`SPEC.md + memory_map.md + interface.vh`

---

### Phase 1：单线程 CPU 重写跑通（先立住地基）

**成员 A 主做：**

* 重写 CPU 骨架（取指/译码/执行/访存/写回）
* 先不做多线程、先不接 muldiv、DMA 先空壳
* 把“内存”先做成最简单 BRAM 模型跑仿真

**成员 B 同步做：**

* 写测试框架（testbench + 指令/数据初始化）
* 做一个“golden 检查”：跑完 dump 寄存器/内存，与预期对比

验收标准：

* 你们选的指令集基本指令全过（加/减/逻辑/移位/跳转/访存…）
* 仿真 OK + 板子下载跑一个小程序 OK

---

### Phase 2：加入 2-thread 多线程（成员 A 的主秀点）

**成员 A：**

* 加 `tid` 标签到流水线寄存器
* 实现 `PC[2] + RegFile[2]`
* 实现调度器：round-robin + skip blocked
* 分支/跳转：只影响对应 tid 的 PC；并且能 flush 同 tid 的错误取指（用 valid+tid 比较清掉即可）

**成员 B：**

* 压测用例：两个线程分别跑不同循环、写不同内存区域，最后校验结果
* 给 A 提出“最容易出 bug 的场景”用例（分支交错、访存交错）

验收标准（必须有“可展示”的现象）：

* 两个线程能同时跑，互不污染寄存器
* 线程0改 r1 不影响线程1的 r1
* 线程0的 PC 变化不影响线程1

---

### Phase 3：加入多周期 MUL/DIV，并让多线程“隐藏延迟”（你们第二个大亮点）

**成员 B 主做：muldiv_unit**

* 先做乘法（Booth+压缩树/CSA），再做除法（non-restoring）
* 做独立 testbench：随机向量对拍（用 Python 或 Verilog reference 也行）
* 通过后输出：`done/result/tid/rd`

**成员 A 主做：CPU 集成**

* 在 decode/execute 遇到 MUL/DIV：

  * 发起 `start`
  * `blocked[tid]=1`
  * 调度器跳过该 tid
* `done` 后写回寄存器并解锁线程

验收标准（强烈建议录一段 demo）：

* 线程0疯狂做 MUL（多周期）
* 线程1做简单加法/IO
* 现象：线程1“几乎不被拖慢”，同时线程0最终得到正确乘法结果
  → 这就是你们多线程的价值展示。

---

### Phase 4：DMA + 中断（系统级亮点）

**成员 B 主做：DMA + mem_subsystem**

* 实现 DMA 寄存器映射（地址解码）
* DMA 搬运 FSM（read->write->count）
* 内存连接：优先双口 BRAM（CPU 口、DMA 口独立）

**成员 A 主做：CPU 中断入口/eret**

* 支持 `irq` 输入
* 仅线程0响应（最简单）
* 保存/恢复 EPC，跳转到中断向量
* 写一个 ISR：读 DMA status、清 done、点亮 LED/写内存标志

验收标准（最好做两个 demo）：

1. CPU 启动 DMA 后继续算 checksum；DMA 完成中断通知
2. CPU 启动 DMA 后执行 `wait/halt`（或空循环），DMA done 中断把 CPU 拉回 ISR 点灯

---

## 5. 三个“申优级别”的展示程序

### Demo 1：硬件多线程正确性

* 线程0：计算 1..N 求和，把结果写 mem[0x100]
* 线程1：计算斐波那契/CRC，把结果写 mem[0x200]
* 最后统一校验内存结果正确

### Demo 2：多线程隐藏 MUL/DIV 延迟

* 线程0：大量 mul/div（例如矩阵乘的小内核）
* 线程1：控制 LED 闪烁或 UART 输出计数
* 现象：即使 thread0 被 muldiv 阻塞，thread1 仍持续输出（几乎不卡）

可选变体（展示访存等待隐藏）：

* 线程0：循环执行 lw/sw，测试端人为插入 mem_ready stall
* 线程1：持续计数/输出
* 现象：数据口等待时 thread1 仍持续前进

### Demo 3：DMA + 中断 + CPU 并行

* 初始化一段内存 src 填充递增数
* CPU 启动 DMA 拷贝到 dst
* CPU 同时计算 src 的校验和/做别的任务
* DMA 完成触发中断，ISR 校验 dst 正确并点亮 LED（写 IO_LED）

---

## 6. 重写时最容易翻车的 6 个点（提前防）

1. **tid 没进流水寄存器** → 写回写错 bank
2. **分支 flush 没按 tid 精准清** → 另一个线程被误杀
3. **muldiv done 写回与 CPU 写回冲突** → 同周期双写 regfile

   * 解决：给 muldiv 写回一个独立端口，或规定 muldiv done 写回优先级
4. **DMA 与 CPU 同时写内存** → 数据竞争

   * 解决：demo 时避免同地址；或加简单仲裁/互斥规则
5. **中断进入时 pipeline 没清 tid0 的飞行指令** → EPC/寄存器状态乱

   * 解决：中断时至少对 tid0 做 flush（valid=0），tid1 可继续
6. **板级验证比仿真难**（时序/初始化）

   * 解决：所有寄存器复位值明确；BRAM 初始化用 COE/MIF/initial 块

---

## 7. 一个很实用的协作方式（保证两人不互相卡）

* 每周/每两天一次“接口冻结点”：接口不再随意改
* 每个 feature 分支合并前：

  * 跑回归：基础指令测试 + 双线程测试 + muldiv 测试 + DMA 测试
* 任何模块交付必须附带：

  1. 接口说明
  2. 独立 testbench
  3. 至少一个能复现的用例

---

## 8. 你们最终报告怎么写才能“对得上申优点”

按老师要求，你们三大亮点对应三章（每章都要“思路 + 实现 + 效果 + 代码关键段”）：

1. **硬件多线程架构设计**：tid 标签、PC/Regfile 双份、调度器、flush 策略
2. **多周期高速乘除法单元**：Booth/压缩树/除法算法、握手、线程阻塞与隐藏延迟
3. **DMA + 中断系统**：寄存器映射、搬运 FSM、并行性、中断服务流程

再加一个“性能分析与对比”：

* 单线程 + 串行乘除 vs 双线程 + muldiv
* CPU memcpy vs DMA memcpy（或 CPU + DMA 并行）
